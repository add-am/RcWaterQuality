---
title: "Inshore Marine Water Quality Data Analysis and Scoring"
subtitle: "A Healthy Waters Partnership Analysis"
description: "Script 2 in a series of script designed to analyse, score, and present inshore marine water quality in the Dry Tropics region. The output of this is used in the Dry Tropics Technical Report."
author: "Adam Shand"
format: html
params:
  script_crs: "EPSG:7844"
  script_fyear: 2024
  sites_removed: TRUE
---

::: {.callout-note}
## Note
Params with the yaml of this script allow a choice between datasets that have "offending" sites removed, and datasets that contain all data. Choose appropriately depending on your needs!
:::

```{r}

#load in a custom function to get yaml parameters
source("functions/get_quarto_params.R")

params <- get_quarto_params()

#return each param as its own object
script_crs <- params$script_crs
script_fyear <- params$script_fyear
sites_removed <- params$sites_removed

```

# Introduction

The purpose of this script is to perform the main data analysis, as well as calculate final results for the inshore water quality data in the Dry Tropics technical report. Key steps include:

 - Loading in data prepared by script 1 of the series.
 - Re-calculating summary stats to be saved to the main output folder (note these were originally calculated in script 1 to help with EDA checks).
 - Calculating the annual median or mean values (directly from the raw values) for all indicators
 - Calculating the standardised scores for all indicators for all:
    + Geographic areas
 - Summing indicators to calculate indicator categories
 - Summing indicator categories to calculate the water quality index
 - Calculating the standardised scores for all indicator, indicator categories, and indices, by taking the mean value for each:
    + Sub Zone
    + Zone
 - Converting all scores to grades.
 - Rounding final values (floor rounding where appropriate).
 - Saving various data tables that will be used in the technical report.


# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below. Key variables and paths are also created.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(tidyverse, glue, here, janitor, openxlsx2, reactable)

#install/load the custom RcTools package
#pak::pak("add-am/RcTools")
library(RcTools)

#load in the custom function used to create the read and write folders for the script
source("functions/setup_helper.R")

#get the required paths
paths <- setup_helper(script_fyear)
data_path <- paths[[1]]
output_path <- paths[[2]]

#turn off scientific notation
options(scipen = 999)

```

# Load Data

Data for this script is provided in a single spreadsheet that was prepared by script 1 in this series of scripts. Please note that script 1 may have removed some offending values, if this is the case a warning will notify as such.

```{r}
#| label: load data
#| warning: true

if (file.exists(glue("{data_path}_sites_removed.csv")) & sites_removed == TRUE){ #if post removed exists, and that is what you want
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}_sites_removed.csv"))
  
  #provide a notifying warning
  warning("The data that has been loaded in has had some values removed as per the QA/QC checks 
          performed in script 1 of this series. Please confirm this is the dataset you would like
          to use.")
  
} else if (file.exists(glue("{data_path}.csv"))){ #if a dataset that never needed removal exists
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}.csv"))
  
} else { #otherwise, take the pre removal dataset
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}_pre_removal.csv"))
    
}

#run name cleaning function
inshore_wq_all <- name_cleaning(inshore_wq_all)

#convert columns to factors and give them the custom order we use in the technical report
inshore_wq_all <- inshore_wq_all |> 
  mutate(across(c(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea), factor),
         BasinOrZone = fct_relevel(BasinOrZone, "Cleveland Bay", "Halifax Bay"), 
         SubBasinOrSubZone = fct_relevel(SubBasinOrSubZone, "CB.Enclosed Coastal", "CB.Open Coastal", "Magnetic Island",
                                "HB.Enclosed Coastal", "HB.Open Coastal", "Midshelf"), 
         WatercourseOrGeographicArea = fct_relevel(WatercourseOrGeographicArea, "EC.Inside Port Zone", "EC.Outside Port Zone",
                                       "OC.Inside Port Zone", "OC.Outside Port Zone", "Magnetic Island",
                                       "H.Enclosed Coastal", "H.Open Coastal", "Midshelf")) 


```

# Calculate Results

Once all the data has been loaded in we can begin to calculate results. However the first step is to calculate some side statistics such as number of samples, and number of months sampled.

```{r}
#| label: calculate side statistics

#select current fy and add the month column
inshore_wq_cy <- inshore_wq_all |> filter(Fy == script_fyear) |> 
  mutate(Month = month(Date, label = TRUE))

#calculate the number of months sampled, and the total number of samples
inshore_wq_cy <- inshore_wq_cy |> 
  group_by(Region, Environment, BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, Fy, Indicator) |> 
  mutate(NMonths = length(unique(Month)),
         NSamples = n()) |> 
  ungroup()

```

## Annual Means/Medians

First we will calculate the annual mean/median values directly from the sample data.

```{r}
#| label: Calculate annual medians

#group up using the same reverse grouping trick and calculate values
is_wq_annual <- inshore_wq_cy |>  
  group_by(
    Region, Environment, BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, 
    Fy, NMonths, NSamples, Indicator, Units, Wqo, Stat) |>
  mutate(AnnualMeanValues = mean(Values, na.rm = TRUE),
         AnnualMedianValues = median(Values, na.rm = TRUE)) |> 
  ungroup()

```

## Select Correct Stat

As you may have noticed we are calculating both means and medians currently. This is because some indicators use means, while others use medians. Below we select the correct stat for each indicator and merge them into one column.

```{r}
#| label: select correct statistic

#select correct stat and merge
is_wq_annual <- is_wq_annual |> 
  mutate(AnnualStatValues = case_when(
    Stat == "mean" ~ AnnualMeanValues,
    TRUE ~ AnnualMedianValues))

```

### Side Tangent: Summary Stats

Part of the technical report includes summary statistics. Below we stylize and present these stats. The table is showed below.

```{r}
#| label: Summary statistics

#stylize table
inshore_summary_stats <- is_wq_annual |> 
  select(WatercourseOrGeographicArea, Indicator, NSamples, NMonths, AnnualStatValues, Wqo) |> 
  unique() |> 
  mutate(across(c(Indicator), factor),
         Indicator = fct_relevel(Indicator, "Nox", "Pn", "Pp", "Tp", "TN", "FRP", "Turbidity", "Tss", "Secchi", "Chla"), 
         AnnualStatValues = round(AnnualStatValues, 4)) |> 
  arrange(Indicator, WatercourseOrGeographicArea)

#save the data
save_n3_table(
  inshore_summary_stats,
  glue("{output_path}/summary_statistics"),
  target_columns = c(5:6),
  target_rows = 1:nrow(inshore_summary_stats),
  scheme = "Summary Statistic"
)

#Important note: Variables for which "success" is to be greater than the water quality objective need to have their colours reversed.

#create object to present in the rendered quarto document
summary_table_present <- reactable(inshore_summary_stats)

```

## Cap Scores

To standardise scores we will use a capping method, to limit scores to be between -1 and +1.

```{r}
#| label: cap scores

is_wq_annual_scored <- value_to_score(
  is_wq_annual,
  AnnualStatValues,
  "Water Quality",
  "Marine",
  Indicator,
  Wqo
)

#refine dataset to just columns and rows we want
is_wq_annual_scored <- is_wq_annual_scored |> 
  select(Region, BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, Indicator, AnnualStatValuesScore) |> 
  distinct() |> 
  filter(!is.na(AnnualStatValuesScore))

```

## Indicator Category Scores:

### Geographic Area

To calculate indicator category and index scores we first need to prepared the data somewhat.

```{r}
#| label: prepare data

#pivot data wider and convert columns to factors to set up for the impending calculation
is_wq_annual_wide <- is_wq_annual_scored |> 
  pivot_wider(names_from = Indicator, values_from = AnnualStatValuesScore)

#clean the names up
is_wq_annual_wide <- name_cleaning(is_wq_annual_wide)

```

Before we can then perform the require rowwise operations.

```{r}
#| label: calculate indicator category and index scores

#calculate indicator categories and indices scores
is_wq_all <- is_wq_annual_wide |> 
  rowwise() |> 
  mutate(Nutrients = mean(c(Nox, Pn, Pp, Tp), na.rm = TRUE),
         PhysChem = mean(c(Turbidity, Tss, Secchi), na.rm = TRUE),
         across(where(is.numeric), ~ifelse(is.infinite(.), NA, .))) |>
  ungroup()

```

### Sub Zones and Zones

Once all scores have been calculated at the geographic area level, they can be averaged up to each of the subsequent levels (sub zone and zone).

```{r}
#| label: calculate scores for sub basins and basins

#group at each level and get the mean of each indicator, indicator category, and index, at that level
sub_zone_scores <- is_wq_all |> 
  group_by(Region, BasinOrZone, SubBasinOrSubZone) |> 
  summarise(across(
    c(Chla, Nox, Pn, Pp, Secchi, Tss, Turbidity, Tn, Tp, Frp, Nutrients, PhysChem), 
    \(x) mean(x, na.rm = TRUE)
  )) |> 
  ungroup()

#as above
zone_scores <- is_wq_all |> select(-WatercourseOrGeographicArea) |>  
  group_by(Region, BasinOrZone) |> 
  summarise(across(
    c(Chla, Nox, Pn, Pp, Secchi, Tss, Turbidity, Tn, Tp, Frp, Nutrients, PhysChem),
    \(x) mean(x, na.rm = TRUE)
  )) |> 
  ungroup()

#combine each of the datasets
is_wq_all_scores <- bind_rows(is_wq_all, sub_zone_scores, zone_scores) 

```

### Side Tangent: Save Sub Zone Scores

A second side tangent we will take here is to save the sub zones scores for nutrients, phys-chem, and the water quality index. These scores need to be added to the appendix.

```{r}
#| label: save sub basin scores

#select specific rows
sub_zone_scores_save <- sub_zone_scores |> ungroup() |> 
  select(SubBasinOrSubZone, Nutrients, PhysChem, Chla) |> 
  rowwise() |> 
  mutate(OverallWq = mean(c(Nutrients, PhysChem, Chla), na.rm = T)) |> 
  ungroup() |> 
  mutate(across(where(is.numeric), floor))

save_n3_table(
  sub_zone_scores_save,
  glue("{output_path}/inshore_appendix_sub_basin_scores"),
  c(2:5),
  1:nrow(sub_zone_scores_save),
  scheme = "Report Card"
)

```

## Index Scores

Next we can calculate the index scores by taking the mean of the indicator category scores. 

Note that I'm not sure why the order of the calculations goes this way, it just does. The impact is we have to run the:
OverallWq = mean(c(Nutrients, PhysChem, Chla), na.rm = TRUE) section a few times through the script.

```{r}
#| label: index scores

is_wq_stand_scores <- is_wq_all_scores |> 
  rowwise() |> 
  mutate(OverallWq = mean(c(Nutrients, PhysChem, Chla), na.rm = TRUE))

```

## Scores to Grades

Finally, scores can be converted to a grade.

```{r}
#| label: convert score to grade

is_wq_all_scores_grades_raw <- score_to_grade(is_wq_stand_scores, 5:length(is_wq_stand_scores))

```

## Floor Rounding

A quirk of the water quality calculations is that all final scores are presented as whole numbers, and any values with decimals are rounded down (floor rounding). 

```{r}
#| label: floor round results

#floor all numeric columns except those that contain the word "Prop" or as these are proportions (need decimals)
is_wq_all_scores_grades_floor <- is_wq_all_scores_grades_raw |> 
  mutate(across(where(is.numeric), floor))

```

# Saving Results

A series of tables need to be created to save the results in a digestible format. These tables include:

 - The entire raw data set
 - The entire dataset with rounding applied (floor rounding where appropriate).
 - Nutrients table (main report; Nox, Pn, Pp, Tp, TN[^1], FRP[^1], Nutrients)
 - Phys Chem table (main report; Turbidity, Tss, Secchi, Phys Chem)
 - Chlorophyll A table (main report; Chla, Chlorophyll a)
 - A summary table (which has already been saved further up).
 
[^1]: These are only added for additional context, they are not currently used to calculate scores.

```{r}
#| label: save data as tables

#save entire raw dataset
write_csv(is_wq_all_scores_grades_raw, glue("{output_path}/is_wq_all_scores_grades_raw.csv"))

#save entire rounded dataset
write_csv(is_wq_all_scores_grades_floor, glue("{output_path}/is_wq_all_scores_grades_floor.csv"))

#select columns for the nutrients table
nutrients_table <- is_wq_all_scores_grades_floor |> 
  select(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, Nox, Pn, Pp, Tp, Tn, Frp, Nutrients) |> 
  arrange(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea)

#select columns for the phys_chem table
physchem_table <- is_wq_all_scores_grades_floor |> 
  select(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, Turbidity, Tss, Secchi, PhysChem) |> 
  arrange(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea)

#select columns for the chlorophyll table
chla_table <- is_wq_all_scores_grades_floor |> 
  select(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea, Chla) |> 
  arrange(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea)

save_n3_table(
  nutrients_table,
  glue("{output_path}/inshore_nutrients"),
  c(4:10),
  1:nrow(nutrients_table),
  scheme = "Report Card"
)

save_n3_table(
  physchem_table,
  glue("{output_path}/inshore_physchem"),
  c(4:7),
  1:nrow(physchem_table),
  scheme = "Report Card"
)

save_n3_table(
  chla_table,
  glue("{output_path}/inshore_chlorophyll"),
  c(4),
  1:nrow(chla_table),
  scheme = "Report Card"
)

```

```{r}


```
