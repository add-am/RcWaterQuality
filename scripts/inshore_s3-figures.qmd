---
title: "Inshore Marine Water Quality Figures"
subtitle: "A Healthy Waters Partnership Analysis"
description: "Script 3 in a series of script designed to analyse, score, and present inshore marine water quality in the Dry Tropics region. The output of this is used in the Dry Tropics Technical Report."
author: "Adam Shand"
format: html
params:
  script_crs: "EPSG:7844"
  script_fyear: 2024
  sites_removed: TRUE 
---

::: {.callout-note}
## Note
Params with the yaml of this script allow a choice between datasets that have "offending" sites removed, and datasets that contain all data. Choose appropriately depending on your needs!
:::

```{r}

#load in a custom function to get yaml parameters
source("functions/get_quarto_params.R")

params <- get_quarto_params()

#return each param as its own object
script_crs <- params$script_crs
script_fyear <- params$script_fyear
sites_removed <- params$sites_removed

```

# Introduction

The purpose of this script is to create stylised figures ready to be presented within the technical report. Figures will include boxplots and line plots.

In the future this script may be expanded to include more unique and customisable code/figures.

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below. Key variables are also created.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(tidyverse, glue, here, janitor, ggplot2)

#install/load the custom RcTools package
#pak::pak("add-am/RcTools")
library(RcTools)

#load in the custom function used to create the read and write folders for the script
source("functions/setup_helper.R")

#get the required paths
paths <- setup_helper(script_fyear)
data_path <- paths[[1]]
output_path <- paths[[2]]

#turn off scientific notation
options(scipen = 999)

```

# Load Data

Data for this script is provided in a single spreadsheet that was prepared by script 1 in this series of scripts. Please note that script 1 may have removed some offending values, if this is the case a warning will notify as such.

```{r}
#| label: load data
#| warning: true
#| 
if (file.exists(glue("{data_path}_sites_removed.csv")) & sites_removed == TRUE){ #if post removed exists, and that is what you want
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}_sites_removed.csv"))
  
  #provide a notifying warning
  warning("The data that has been loaded in has had some values removed as per the QA/QC checks 
          performed in script 1 of this series. Please confirm this is the dataset you would like
          to use.")
  
} else if (file.exists(glue("{data_path}.csv"))){ #if a dataset that never needed removal exists
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}.csv"))
  
} else { #otherwise, take the pre removal dataset
  
  #read in data
  inshore_wq_all <- read_csv(glue("{data_path}_pre_removal.csv"))
    
}

#convert columns to factors and give them the custom order we use in the technical report
inshore_wq_all <- inshore_wq_all |> 
  mutate(across(c(BasinOrZone, SubBasinOrSubZone, WatercourseOrGeographicArea), factor),
         BasinOrZone = fct_relevel(BasinOrZone, "Cleveland Bay", "Halifax Bay"), 
         SubBasinOrSubZone = fct_relevel(SubBasinOrSubZone, "CB.Enclosed Coastal", "CB.Open Coastal", "Magnetic Island",
                                "HB.Enclosed Coastal", "HB.Open Coastal", "Midshelf"), 
         WatercourseOrGeographicArea = fct_relevel(WatercourseOrGeographicArea, "EC.Inside Port Zone", "EC.Outside Port Zone",
                                       "OC.Inside Port Zone", "OC.Outside Port Zone", "Magnetic Island",
                                       "H.Enclosed Coastal", "H.Open Coastal", "Midshelf")) 

#cut off data that is past the targeted financial year - this is important to be able to replicate old graphs
inshore_wq_target <- inshore_wq_all |> filter(Fy <= script_fyear)

```

# Boxplots

First we will create the boxplots that are used in the appendix of the technical report. Noting that most boxplots share the same core features and just have variations around their y scale.

```{r}
#| label: create boxplots 

#create custom log function for tick breaks
base_breaks <- function(n = 10){
    function(x) {
        axisTicks(log10(range(x, na.rm = TRUE)), log = TRUE, n = n)
    }
}

#boxplot data only requires the current year to work
boxplot_data <- inshore_wq_target |> filter(Fy == script_fyear)

theme_set(theme_bw(8))

#create a custom colour scheme
boxplot_colours <- c("#A6CEE3", "#B15928","#FFFF99","#E31A1C", "#B2DF8A", "#CAB2D6")

for (i in unique(boxplot_data$Indicator)){#for each of the indicators
  
  #pick out data
  target_data <- boxplot_data |> filter(Indicator == i)
  
  #pick out the associated units
  units <- unique(target_data$Units)
  
  #set the location of the sub title for cleveland bay
  if (i %in% c("Chla", "PN", "PP", "NOX", "Secchi", "TSS", "Turbidity")){
    
    cleve_sub_title_location <- "Magnetic Island"
  
  } else {
      
    cleve_sub_title_location <- "OC.Outside Port Zone"
  
  }
  
    #set the location of the sub title for halfax bay
  if (i %in% c("PN", "PP", "Secchi")){
    
    hali_sub_title_location <- "H.Open Coastal"
  
  } else {
      
    hali_sub_title_location <- "H.Enclosed Coastal"
  
  }
    
  
  #start the main plot which contains features consistent across all indicators
  box_plot <- ggplot(target_data) +
    geom_boxplot(mapping = aes(x = WatercourseOrGeographicArea, y = Values, fill = SubBasinOrSubZone, alpha = 0.3), show.legend = FALSE) +
    scale_fill_manual(values = boxplot_colours) +
    annotate(geom = "text", x = cleve_sub_title_location, y = 140, label = "Cleveland Bay", size = 3, hjust = 0.4) +
    annotate(geom = "text", x = hali_sub_title_location, y = 140, label = "Halifax Bay", size = 3, hjust = 0.5) +
    geom_point(mapping = aes(x = WatercourseOrGeographicArea, y = Wqo), color = "blue", shape = 23, fill = "blue", size = 2) +
    theme_bw() + 
    theme(panel.border = element_rect(), panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(angle = 90, vjust = 0.5, size = 7), 
          axis.title = element_text(size = 10)) +
    ylab(glue("{i} ({units})")) +
    scale_y_continuous(trans = scales::log_trans(), breaks = base_breaks(), labels = prettyNum)
  
  #save plot
  ggsave(filename = glue("{output_path}/boxplot_{i}.png"), plot = box_plot, width = 16.2, height = 10, units = "cm")
  
}

```

# Lineplots

Then we will create line plots that are also presented in the appendix.

```{r}
#| label: create lineplots

#create a custom color palette
lineplot_colours <- c("#A6CEE3", "#084594", "#B15928", "#BF812D", "#01665E", "#FB6A4A", "#99000D","#B2DF8A")

#assign names to each colour so ggplot can match the name to the colour
names(lineplot_colours) <- levels(unique(inshore_wq_target$WatercourseOrGeographicArea))

for (i in unique(inshore_wq_target$Indicator)){#for each indicator
  
  #select the data 
  target_data <- inshore_wq_target |> filter(Indicator == i) |> 
    filter(!is.na(Values))
  
  #and the units
  units <- unique(target_data$Units)
  
  #plot
  line_plot <- ggplot(target_data) +
    geom_line(mapping = aes(x = Date, y = Values, color = WatercourseOrGeographicArea)) +
    scale_color_manual(values = lineplot_colours) +
    geom_line(mapping = aes(x = Date, y = Wqo), color = "black") +
    facet_wrap(~WatercourseOrGeographicArea, scales = "free") +
    ylab(glue("{i} ({units})"))
  
  #save
  ggsave(filename = glue("{output_path}/lineplot_{i}.png"), plot = line_plot, width = 16, height = 20, units = "cm")
    
}

```

```{r}

```
